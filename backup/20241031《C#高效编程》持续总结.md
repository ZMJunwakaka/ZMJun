## 1.使用属性而不是可访问的数据成员
## 2.用运行时常量readonly而不是编译期常量const
在 C# 中，使用 `readonly` 字段而不是 `const` 常量在许多情况下是一个更好的选择，尤其是当需要在运行时确定值时。以下是两者的主要区别和使用场景：

#### `const` 常量
- **编译期常量**：`const` 修饰符定义的常量在编译时确定值，无法更改。
- **静态**：`const` 字段隐式为 `static`，它的值在所有类实例中共享。
- **使用限制**：`const` 只能用于基本数据类型（如 `int`、`string` 等），无法用于复杂对象，且不支持动态计算。

#### `readonly` 字段
- **运行时常量**：`readonly` 修饰符定义的字段可以在构造函数中设置，允许在运行时确定其值。
- **实例或静态**：`readonly` 字段可以是实例字段，也可以是静态字段，这意味着你可以为每个实例设置不同的值。
- **更灵活**：`readonly` 可以用于复杂类型，允许在创建对象时根据传入的参数或其他逻辑来设置值。

#### 使用场景
- **使用 `const`**：适用于那些不需要在运行时确定且在所有实例中都相同的简单值，如数学常量（如 `Math.PI`）。

- **使用 `readonly`**：适用于需要在运行时决定值的情况，或需要不同实例有不同值的情况，如依赖注入或配置参数。

总的来说，`readonly` 提供了更大的灵活性和可扩展性，通常是更优的选择。

#### `readonly` 字段赋值
`readonly` 字段不仅可以在构造器中赋值，还可以在其声明时直接赋值。以下是两种赋值方式的说明：

1. **声明时赋值**：可以在定义字段时直接给 `readonly` 字段赋值。这种方式在字段的生命周期内保持不变。

   ```csharp
   public class Example
   {
       public readonly int Value = 42; // 声明时赋值

       public Example() { }
   }
   ```

2. **构造器赋值**：可以在类的构造器中对 `readonly` 字段进行赋值，这允许在对象创建时根据参数或逻辑设置其值。

   ```csharp
   public class Example
   {
       public readonly int Value;

       public Example(int value)
       {
           Value = value; // 构造器中赋值
       }
   }
   ```

在对象实例化后，`readonly` 字段的值不能被更改，因此它提供了一种有效的方式来确保字段的不可变性。
## 3.推荐使用is或as操作符而不是强制类型转换
1.强制类型转换用法
2.is
3as