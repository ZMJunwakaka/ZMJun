## 1.使用属性而不是可访问的数据成员
## 2.用运行时常量readonly而不是编译期常量const
在 C# 中，使用 `readonly` 字段而不是 `const` 常量在许多情况下是一个更好的选择，尤其是当需要在运行时确定值时。以下是两者的主要区别和使用场景：

#### `const` 常量
- **编译期常量**：`const` 修饰符定义的常量在编译时确定值，无法更改。
- **静态**：`const` 字段隐式为 `static`，它的值在所有类实例中共享。
- **使用限制**：`const` 只能用于基本数据类型（如 `int`、`string` 等），无法用于复杂对象，且不支持动态计算。

#### `readonly` 字段
- **运行时常量**：`readonly` 修饰符定义的字段可以在构造函数中设置，允许在运行时确定其值。
- **实例或静态**：`readonly` 字段可以是实例字段，也可以是静态字段，这意味着你可以为每个实例设置不同的值。
- **更灵活**：`readonly` 可以用于复杂类型，允许在创建对象时根据传入的参数或其他逻辑来设置值。

#### 使用场景
- **使用 `const`**：适用于那些不需要在运行时确定且在所有实例中都相同的简单值，如数学常量（如 `Math.PI`）。

- **使用 `readonly`**：适用于需要在运行时决定值的情况，或需要不同实例有不同值的情况，如依赖注入或配置参数。

总的来说，`readonly` 提供了更大的灵活性和可扩展性，通常是更优的选择。

#### `readonly` 字段赋值
`readonly` 字段不仅可以在构造器中赋值，还可以在其声明时直接赋值。以下是两种赋值方式的说明：

1. **声明时赋值**：可以在定义字段时直接给 `readonly` 字段赋值。这种方式在字段的生命周期内保持不变。

   ```csharp
   public class Example
   {
       public readonly int Value = 42; // 声明时赋值

       public Example() { }
   }
   ```

2. **构造器赋值**：可以在类的构造器中对 `readonly` 字段进行赋值，这允许在对象创建时根据参数或逻辑设置其值。

   ```csharp
   public class Example
   {
       public readonly int Value;

       public Example(int value)
       {
           Value = value; // 构造器中赋值
       }
   }
   ```

在对象实例化后，`readonly` 字段的值不能被更改，因此它提供了一种有效的方式来确保字段的不可变性。
## 3.推荐使用is或as操作符而不是强制类型转换
在 C# 中，强制类型转换、`is` 和 `as` 操作符都是用于处理类型转换的工具。它们各自的用法和推荐场景如下：

### 强制类型转换
- **语法**：使用括号表示目标类型，例如 `(TargetType)value`。
- **特点**：
  - 如果转换失败，会抛出 `InvalidCastException`。
  - 适用于已知类型安全的转换。

  ```csharp
  object obj = "Hello";
  string str = (string)obj; // 强制转换，安全
  ```

### `is` 操作符
- **用法**：用于检查对象是否是特定类型，返回布尔值。
- **特点**：
  - 在 C# 7.0 及之后的版本中，可以直接在条件语句中声明转换变量。

  ```csharp
  object obj = "Hello";
  if (obj is string str)
  {
      // str 在这里被视为 string 类型
      Console.WriteLine(str); // 输出: Hello
  }
  ```

### `as` 操作符
- **用法**：用于尝试将对象转换为指定类型，转换成功时返回该类型的对象，失败时返回 `null`。
- **特点**：
  - 适用于可能为空的转换，避免了异常抛出。

  ```csharp
  object obj = "Hello";
  string str = obj as string; // 如果转换失败，str 会是 null
  if (str != null)
  {
      Console.WriteLine(str); // 输出: Hello
  }
  ```

### 推荐使用
- **使用 `is` 和 `as`**：在不确定对象类型的情况下，推荐使用 `is` 和 `as`。这可以避免运行时异常，提供更安全的转换方式。
- **强制类型转换**：在确认对象确实可以安全转换的情况下使用，通常在性能关键的场景中。

总之，`is` 和 `as` 提供了更安全的方式来进行类型检查和转换，因此在大多数情况下推荐使用它们。
## 4.使用Conditional特性而不是#if条件编译
## 5.为类型提供ToString( )方法
## 6.理解几个等同性判断之间的关系
1. public static bool ReferenceEquals(object left, object right);
2.public static bool Equals(object left, object right);
3.public virtual bool Equals(object right);
4.public static bool operator ==(MyClass left, MyClass right);
5==